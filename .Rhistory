start_date <- strptime(data_inizio, "%Y-%m-%d %H:%M:%S")
end_date <- start_date + hours(23)
#Sequenza di date da elaborare
vec_date <- seq(start_date,end_date, by = '1 hour')
print(paste(vec_date))
#Isolo il tempo e il giorno dalla stringa data e ora
time <- strftime(vec_date,format="%H:%M:%S",tz = "UTC")
day <- strftime(vec_date[1], format="%d-%m")
#Ciclo sommo le ore
for (i in 1:length(vec_date)){
r_link <- paste(base_string,date(vec_date[i]),"T",time[i],".000Z%22)&FORMAT=image/tiff",sep = "")
print(paste(r_link))
if(url.exists(r_link)){
rstr_finale = rstr_finale + raster(r_link)
} else {
print("Errore: non accedo al raster")
}
}
#Calcolo della temperatura media
print(length(vec_date))
writeRaster(rstr_finale, filename="C:\\WSL_folder\\tm2_ana_somma_MZ.ti", format = "GTiff", overwrite = TRUE)
rstr_finale <- rstr_finale / 24
#L'istruzione di seguito è commentata perchè permette di scrivere il raster giornaliero per uso locale
#Scrivo il raster giornaliero
name=paste0("t2m_ana_",date(vec_date[1]))
filename=paste("C:\\WSL_folder\\",name,".tif",sep = "")
writeRaster(rstr_finale, filename=filename, format = "GTiff", overwrite = TRUE)
print(paste0("Raster salvato in: ", filename))
###################################################  Esempio semplice di Elaborazione grafica del raster (tmap library) ######################################
#Creazione delle isolinee da aggiungere al grafico
rc <- rasterToContour(rstr_finale)
#Assegno il sistema di riferimento WGS84-UTM32N
proj4string(rstr_finale) <- CRS("+init=epsg:32632")
#Creo il grafico. La documentazione della libreria è disponibile qui: https://cran.r-project.org/web/packages/tmap/tmap.pdf
#install.packages("tmap")
library(tmap)
#figure=paste0("C:\\WSL_folder\\",name,".png")
#png(figure)
# make plot
tm_shape(rstr_finale) + tm_raster(style= "cont", palette = "-RdYlBu", title = paste("Tmedia del ",day,"\n (°C)"), interpolate = TRUE) +
tm_shape(rc) + tm_lines(col = "black", text = "level", breaks = rc$level, labels = as.character(rc$level)) +
tm_text("level", col = "white", size = 1.0) + tm_legend(outside = TRUE)
#close del plot and save it
#dev.off()
#END SCRIPT
#Calcolo della temperatura media
print(length(vec_date))
writeRaster(rstr_finale, filename="C:\\WSL_folder\\tm2_ana_somma_MZ.ti", format = "GTiff", overwrite = TRUE)
rstr_finale <- rstr_finale / 24
#L'istruzione di seguito è commentata perchè permette di scrivere il raster giornaliero per uso locale
#Scrivo il raster giornaliero
name=paste0("t2m_ana_",date(vec_date[1]))
filename=paste("C:\\WSL_folder\\",name,".tif",sep = "")
writeRaster(rstr_finale, filename=filename, format = "GTiff", overwrite = TRUE)
print(paste0("Raster salvato in: ", filename))
###################################################  Esempio semplice di Elaborazione grafica del raster (tmap library) ######################################
#Creazione delle isolinee da aggiungere al grafico
rc <- rasterToContour(rstr_finale)
#Assegno il sistema di riferimento WGS84-UTM32N
proj4string(rstr_finale) <- CRS("+init=epsg:32632")
#Creo il grafico. La documentazione della libreria è disponibile qui: https://cran.r-project.org/web/packages/tmap/tmap.pdf
#install.packages("tmap")
library(tmap)
# B1) Vedere la procedura in R di Zanetti. Raster per il giorno 26/10/2020 salvato come t2m_ana_2020-10-26.tif
rasterMZ=raster("C:\\WSL_folder\\t2m_ana_2020-10-26.tif")
values <- raster::extract(raster_gg, pointCoordinates)
valori_MZ <- raster::extract(rasterMZ, pointCoordinates)
x <- data.frame(pointCoordinates)
tmp <- cbind(x, tm2_ana_gg=values, tm2_ana_gg_MZ=valori_MZ)
tmp
#Script per l'elaborazione della temperatura media giornaliera a partire da dati orari "scaricati" da Rasdaman #
#Esecutore script: MZ                                                                                          #
#La procedura è¨ pensata per "girare" ogni gg con elaborazione del giorno precedente,                          #
#Nel caso l'utente voglia scegliere il giorno è necessario scommentare le prime righe dopo la definizione      #
#delle librerie.                                                                                               #
################################################################################################################
library(raster)
library(tmap)
library(RColorBrewer)
library(rgdal)
library(lubridate)
library(anytime)
library(RCurl)
#Scommentare se si vuole scegliere autonomamente il giorno
#start_date <- "20201026"
#start_date <- ymd(start_date) + hours(1)
#Stringa di base per la composizione del link da elaborare
base_string <- "http://10.10.0.28:8081/rasdaman/ows?&SERVICE=WCS&VERSION=2.0.1&REQUEST=GetCoverage&COVERAGEID=t2m_ana&SUBSET=ansi(%22"
#Definizione temporale del periodo da elaborare (procedura in automatico), da commentare nel caso di scelta giorno dell'utente
data_inizio="2020-10-26 00:00:00"
start_date <- strptime(data_inizio, "%Y-%m-%d %H:%M:%S")
end_date <- start_date + hours(23)
#Sequenza di date da elaborare
vec_date <- seq(start_date,end_date, by = '1 hour')
print(paste(vec_date))
#Isolo il tempo e il giorno dalla stringa data e ora
time <- strftime(vec_date,format="%H:%M:%S",tz = "UTC")
day <- strftime(vec_date[1], format="%d-%m")
#Ciclo sommo le ore
for (i in 1:length(vec_date)){
r_link <- paste(base_string,date(vec_date[i]),"T",time[i],".000Z%22)&FORMAT=image/tiff",sep = "")
print(paste(r_link))
if(url.exists(r_link)){
rstr_finale = rstr_finale + raster(r_link)
} else {
print("Errore: non accedo al raster")
}
}
#Calcolo della temperatura media
print(length(vec_date))
writeRaster(rstr_finale, filename="C:\\WSL_folder\\tm2_ana_somma_MZ.ti", format = "GTiff", overwrite = TRUE)
rstr_finale <- rstr_finale / 24
################################################################################################################
library(raster)
library(tmap)
library(RColorBrewer)
library(rgdal)
library(lubridate)
library(anytime)
library(RCurl)
#Scommentare se si vuole scegliere autonomamente il giorno
#start_date <- "20201026"
#start_date <- ymd(start_date) + hours(1)
#Stringa di base per la composizione del link da elaborare
base_string <- "http://10.10.0.28:8081/rasdaman/ows?&SERVICE=WCS&VERSION=2.0.1&REQUEST=GetCoverage&COVERAGEID=t2m_ana&SUBSET=ansi(%22"
#Definizione temporale del periodo da elaborare (procedura in automatico), da commentare nel caso di scelta giorno dell'utente
data_inizio="2020-10-26 00:00:00"
start_date <- strptime(data_inizio, "%Y-%m-%d %H:%M:%S")
end_date <- start_date + hours(23)
#Sequenza di date da elaborare
vec_date <- seq(start_date,end_date, by = '1 hour')
print(paste(vec_date))
#Isolo il tempo e il giorno dalla stringa data e ora
time <- strftime(vec_date,format="%H:%M:%S",tz = "UTC")
day <- strftime(vec_date[1], format="%d-%m")
#rstr_finale
rstr_finale=raster()
#Ciclo sommo le ore
for (i in 1:length(vec_date)){
r_link <- paste(base_string,date(vec_date[i]),"T",time[i],".000Z%22)&FORMAT=image/tiff",sep = "")
print(paste(r_link))
if(url.exists(r_link)){
rstr_finale = rstr_finale + raster(r_link)
} else {
print("Errore: non accedo al raster")
}
}
#Calcolo della temperatura media
print(length(vec_date))
writeRaster(rstr_finale, filename="C:\\WSL_folder\\tm2_ana_somma_MZ.ti", format = "GTiff", overwrite = TRUE)
rstr_finale <- rstr_finale / 24
################################################################################################################
library(raster)
library(tmap)
library(RColorBrewer)
library(rgdal)
library(lubridate)
library(anytime)
library(RCurl)
#Scommentare se si vuole scegliere autonomamente il giorno
#start_date <- "20201026"
#start_date <- ymd(start_date) + hours(1)
#Stringa di base per la composizione del link da elaborare
base_string <- "http://10.10.0.28:8081/rasdaman/ows?&SERVICE=WCS&VERSION=2.0.1&REQUEST=GetCoverage&COVERAGEID=t2m_ana&SUBSET=ansi(%22"
#Definizione temporale del periodo da elaborare (procedura in automatico), da commentare nel caso di scelta giorno dell'utente
data_inizio="2020-10-26 00:00:00"
start_date <- strptime(data_inizio, "%Y-%m-%d %H:%M:%S")
end_date <- start_date + hours(23)
#Sequenza di date da elaborare
vec_date <- seq(start_date,end_date, by = '1 hour')
print(paste(vec_date))
#Isolo il tempo e il giorno dalla stringa data e ora
time <- strftime(vec_date,format="%H:%M:%S",tz = "UTC")
day <- strftime(vec_date[1], format="%d-%m")
#rstr_finale
rstr_finale=raster()
#Ciclo sommo le ore
for (i in 1:length(vec_date)){
r_link <- paste(base_string,date(vec_date[i]),"T",time[i],".000Z%22)&FORMAT=image/tiff",sep = "")
print(paste(r_link))
if(url.exists(r_link)){
rstr_finale = rstr_finale + raster(r_link)
} else {
print("Errore: non accedo al raster")
}
}
#Calcolo della temperatura media
print(length(vec_date))
writeRaster(rstr_finale, filename="C:\\WSL_folder\\tm2_ana_somma_MZ.ti", format = "GTiff", overwrite = TRUE)
rstr_finale <- rstr_finale / 24
################################################################################################################
library(raster)
library(tmap)
library(RColorBrewer)
library(rgdal)
library(lubridate)
library(anytime)
library(RCurl)
#Scommentare se si vuole scegliere autonomamente il giorno
#start_date <- "20201026"
#start_date <- ymd(start_date) + hours(1)
#Stringa di base per la composizione del link da elaborare
base_string <- "http://10.10.0.28:8081/rasdaman/ows?&SERVICE=WCS&VERSION=2.0.1&REQUEST=GetCoverage&COVERAGEID=t2m_ana&SUBSET=ansi(%22"
#Definizione temporale del periodo da elaborare (procedura in automatico), da commentare nel caso di scelta giorno dell'utente
data_inizio="2020-10-26 00:00:00"
start_date <- strptime(data_inizio, "%Y-%m-%d %H:%M:%S")
end_date <- start_date + hours(23)
#Sequenza di date da elaborare
vec_date <- seq(start_date,end_date, by = '1 hour')
print(paste(vec_date))
#Isolo il tempo e il giorno dalla stringa data e ora
time <- strftime(vec_date,format="%H:%M:%S",tz = "UTC")
day <- strftime(vec_date[1], format="%d-%m")
#Assengno il primo raster alla mia variabile che poi andrà a sommare gli altri nel ciclo - controllo di esistenza del raster
test_url <- paste(base_string,date(vec_date[1]),"T",time[1],".000Z%22)&FORMAT=image/tiff",sep = "")
print(paste("inizio:",test_url))
if (url.exists(test_url)){
rstr_finale <- raster(test_url)
} else {
print("Errore: non accedo al raster")
}
#Ciclo sommo le ore
for (i in 2:length(vec_date)){
r_link <- paste(base_string,date(vec_date[i]),"T",time[i],".000Z%22)&FORMAT=image/tiff",sep = "")
print(paste(r_link))
if(url.exists(r_link)){
rstr_finale = rstr_finale + raster(r_link)
} else {
print("Errore: non accedo al raster")
}
}
#Calcolo della temperatura media
print(length(vec_date))
writeRaster(rstr_finale, filename="C:\\WSL_folder\\tm2_ana_somma_MZ.ti", format = "GTiff", overwrite = TRUE)
rstr_finale <- rstr_finale / 24
rasterMZ=raster("C:\\WSL_folder\\t2m_ana_2020-10-26.tif")
values <- raster::extract(raster_gg, pointCoordinates)
valori_MZ <- raster::extract(rasterMZ, pointCoordinates)
x <- data.frame(pointCoordinates)
tmp <- cbind(x, tm2_ana_gg=values, tm2_ana_gg_MZ=valori_MZ)
tmp
pointCoordinates=read.csv("C:\\WSL_folder\\coordinate_stazioni.csv",header =TRUE, sep = ";")
pointCoordinates
CRS=raster_gg@crs
coordinates(pointCoordinates)=~UTM_EST+UTM_NORD
projection(pointCoordinates) <- CRS
#Step1: Plotto le stazioni
#compareCRS(raster_gg, pointCoordinates)
#> [1]TRUE
plot(pointCoordinates, add = TRUE)
# Step2:  Combine raster values with point and save as a CSV file.
values <- raster::extract(raster_gg, pointCoordinates)
valori_MZ <- raster::extract(rasterMZ, pointCoordinates)
x <- data.frame(pointCoordinates)
tmp <- cbind(x, tm2_ana_gg=values, tm2_ana_gg_MZ=valori_MZ)
tmp
pointCoordinates=read.csv("C:\\WSL_folder\\coordinate_stazioni.csv",header =TRUE, sep = ";")
pointCoordinates
CRS=raster_gg@crs
coordinates(pointCoordinates)=~UTM_EST+UTM_NORD
projection(pointCoordinates) <- CRS
################################################################################################################
library(raster)
library(tmap)
library(RColorBrewer)
library(rgdal)
library(lubridate)
library(anytime)
library(RCurl)
#Scommentare se si vuole scegliere autonomamente il giorno
#start_date <- "20201026"
#start_date <- ymd(start_date) + hours(1)
#Stringa di base per la composizione del link da elaborare
base_string <- "http://10.10.0.28:8081/rasdaman/ows?&SERVICE=WCS&VERSION=2.0.1&REQUEST=GetCoverage&COVERAGEID=t2m_ana&SUBSET=ansi(%22"
#Definizione temporale del periodo da elaborare (procedura in automatico), da commentare nel caso di scelta giorno dell'utente
data_inizio="2020-10-26 00:00:00"
start_date <- strptime(data_inizio, "%Y-%m-%d %H:%M:%S")
end_date <- start_date + hours(23)
#Sequenza di date da elaborare
vec_date <- seq(start_date,end_date, by = '1 hour')
print(paste(vec_date))
#Isolo il tempo e il giorno dalla stringa data e ora
time <- strftime(vec_date,format="%H:%M:%S",tz = "UTC")
day <- strftime(vec_date[1], format="%d-%m")
#Assengno il primo raster alla mia variabile che poi andrà a sommare gli altri nel ciclo - controllo di esistenza del raster
test_url <- paste(base_string,date(vec_date[1]),"T",time[1],".000Z%22)&FORMAT=image/tiff",sep = "")
print(paste("inizio:",test_url))
if (url.exists(test_url)){
rstr_finale <- raster(test_url)
} else {
print("Errore: non accedo al raster")
}
#Ciclo sommo le ore
for (i in 2:length(vec_date)){
r_link <- paste(base_string,date(vec_date[i]),"T",time[i],".000Z%22)&FORMAT=image/tiff",sep = "")
print(paste(r_link))
if(url.exists(r_link)){
rstr_finale = rstr_finale + raster(r_link)
} else {
print("Errore: non accedo al raster")
}
}
#Calcolo della temperatura media
print(length(vec_date))
writeRaster(rstr_finale, filename="C:\\WSL_folder\\tm2_ana_somma_MZ.ti", format = "GTiff", overwrite = TRUE)
rstr_finale <- rstr_finale / 24
#L'istruzione di seguito è commentata perchè permette di scrivere il raster giornaliero per uso locale
#Scrivo il raster giornaliero
name=paste0("t2m_ana_",date(vec_date[1]))
filename=paste("C:\\WSL_folder\\",name,".tif",sep = "")
writeRaster(rstr_finale, filename=filename, format = "GTiff", overwrite = TRUE)
print(paste0("Raster salvato in: ", filename))
library(myCubeR)
library(raster)
#library(xml2)
#library(RCurl)
#library(httr)
#library(magrittr)
#library(tiff)
## 2. Connettersi alla VPN per collegarsi a Rasdaman
# Elenco delle coverage disponibili
coverages=getCapability()
coverages
#Selezione della coverage tm2_ana
coverage=getCapability()[5]
coverage
tm2_ana=coverage
#Vediamo quali sono gli estremi delle date disponibili e quali le varie date (per verificare che il dato sia orario)
temp_ext=coverage_get_temporal_extent(coverage=coverage)
temp_ext
# Scegliamo per esempio di voler fare la media giornaliera del giorno 26/10/2020
# A) Verifica. Verifichiamo che ci siano tutti i timestamps
# A1) Con "R"
data_inizio="2020-10-26 00:00:00"
data_fine="2020-10-26 23:00:00"
start.date <- strptime(data_inizio, "%Y-%m-%d %H:%M:%S")
end.date <- strptime(data_fine, "%Y-%m-%d %H:%M:%S")
a=seq(from=start.date, to=end.date, by="hour")  #length(a)
# oppure
# a=seq(from=start.date, by = "hour", length.out = 24)
date_range=format(a, "%Y-%m-%dT%H:%M:%OS3Z")
lista_completa=as.character(date_range)
all_timestamps=coverage_get_timestamps(coverage=tm2_ana)
timestamps=all_timestamps[all_timestamps%in%lista_completa]  #Timestamps presenti in quelle date
difs <- setdiff(lista_completa,timestamps)                   #Timestamp che (eventualmente) mancano in quelle date
print(paste0("[R]: Ci sono ", length(timestamps), " timestamps."))
if (!identical(difs,character(0))) print (paste0("La serie temporale disponibile non è completa! Mancano i timestamps:", difs))
# A2) Conto i numeri di timestamps presenti in quelle date utilizzando una query WCPS da inviare al server Rasdaman
# How many data points are there between 2020-10-26T00:00:00.000Z" e "2020-10-26T23:00:00.000 ?
query1='for $c in ( t2m_ana ) return encode(
condense +
over $t ansi(imageCrsDomain($c[ansi("2020-10-26T00:00:00.000Z":"2020-10-26T23:00:00.000Z")], ansi))
using 1, "text/csv")'
numero=WPCS_query(proper_query=query1, FORMAT="text/csv", filename=NULL, query_url=NULL)
print(paste0("[RASDAMAN]: Ci sono ", numero, " timestamps."))
# B) Calcolo la media giornaliera
# B1) Vedere la procedura in R di Zanetti. Raster per il giorno 26/10/2020 salvato come t2m_ana_2020-10-26.tif
rasterMZ=raster("C:\\WSL_folder\\t2m_ana_2020-10-26.tif")
# B2) Rasdaman
# start=format(start.date, "%Y-%m-%dT%H:%M:%OS3Z")
# end=format(end.date, "%Y-%m-%dT%H:%M:%OS3Z")
# intervallo=paste0('"',start,'":"',end,'"')
##> start: "2020-10-26T00:00:00.000Z"
##> end: "2020-10-26T23:00:00.000Z"
#somma
query='for $c in ( t2m_ana ) return encode(
condense +
over $t ansi(imageCrsDomain($c[ansi("2020-10-26T00:00:00.000Z":"2020-10-26T23:00:00.000Z")], ansi))
using $c[ansi($t)], "tiff")'
raster_tot=WPCS_query(proper_query=query, FORMAT="image/tiff", filename="C:\\WSL_folder\\tm2_ana_somma_RASDAMAN.tiff", query_url=NULL)
#media
query2='for $c in ( t2m_ana ) return encode(
condense +
over $t ansi(imageCrsDomain($c[ansi("2020-10-26T00:00:00.000Z":"2020-10-26T23:00:00.000Z")], ansi))
using ($c[ansi($t)]/23), "tiff")'
raster_gg=WPCS_query(proper_query=query2, FORMAT="image/tiff", filename=NULL, query_url=NULL)
raster_gg
plot(raster_gg)
# Verificare il valore medio in alcuni punti
pointCoordinates=read.csv("C:\\WSL_folder\\coordinate_stazioni.csv",header =TRUE, sep = ";")
pointCoordinates
CRS=raster_gg@crs
coordinates(pointCoordinates)=~UTM_EST+UTM_NORD
projection(pointCoordinates) <- CRS
#Step1: Plotto le stazioni
#compareCRS(raster_gg, pointCoordinates)
#> [1]TRUE
plot(pointCoordinates, add = TRUE)
# Step2:  Combine raster values with point and save as a CSV file.
values <- raster::extract(raster_gg, pointCoordinates)
valori_MZ <- raster::extract(rasterMZ, pointCoordinates)
x <- data.frame(pointCoordinates)
tmp <- cbind(x, tm2_ana_gg=values, tm2_ana_gg_MZ=valori_MZ)
tmp
## 0. Installazione (NB! Scnnettersi dalla VPN)
#library(devtools)
#devtools::install_github("ARPASMR/myCubeR@HEAD")
## 1. Caricamento della libreria MyCubeR
library(myCubeR)
library(raster)
#library(xml2)
#library(RCurl)
#library(httr)
#library(magrittr)
#library(tiff)
## 2. Connettersi alla VPN per collegarsi a Rasdaman
# Elenco delle coverage disponibili
coverages=getCapability()
coverages
#Selezione della coverage tm2_ana
coverage=getCapability()[5]
coverage
tm2_ana=coverage
#Vediamo quali sono gli estremi delle date disponibili e quali le varie date (per verificare che il dato sia orario)
temp_ext=coverage_get_temporal_extent(coverage=coverage)
temp_ext
# Scegliamo per esempio di voler fare la media giornaliera del giorno 26/10/2020
# A) Verifica. Verifichiamo che ci siano tutti i timestamps
# A1) Con "R"
data_inizio="2020-10-26 00:00:00"
data_fine="2020-10-26 23:00:00"
start.date <- strptime(data_inizio, "%Y-%m-%d %H:%M:%S")
end.date <- strptime(data_fine, "%Y-%m-%d %H:%M:%S")
a=seq(from=start.date, to=end.date, by="hour")  #length(a)
# oppure
# a=seq(from=start.date, by = "hour", length.out = 24)
date_range=format(a, "%Y-%m-%dT%H:%M:%OS3Z")
lista_completa=as.character(date_range)
all_timestamps=coverage_get_timestamps(coverage=tm2_ana)
timestamps=all_timestamps[all_timestamps%in%lista_completa]  #Timestamps presenti in quelle date
difs <- setdiff(lista_completa,timestamps)                   #Timestamp che (eventualmente) mancano in quelle date
print(paste0("[R]: Ci sono ", length(timestamps), " timestamps."))
if (!identical(difs,character(0))) print (paste0("La serie temporale disponibile non è completa! Mancano i timestamps:", difs))
# A2) Conto i numeri di timestamps presenti in quelle date utilizzando una query WCPS da inviare al server Rasdaman
# How many data points are there between 2020-10-26T00:00:00.000Z" e "2020-10-26T23:00:00.000 ?
query1='for $c in ( t2m_ana ) return encode(
condense +
over $t ansi(imageCrsDomain($c[ansi("2020-10-26T00:00:00.000Z":"2020-10-26T23:00:00.000Z")], ansi))
using 1, "text/csv")'
numero=WPCS_query(proper_query=query1, FORMAT="text/csv", filename=NULL, query_url=NULL)
print(paste0("[RASDAMAN]: Ci sono ", numero, " timestamps."))
# B) Calcolo la media giornaliera
# B1) Vedere la procedura in R di Zanetti. Raster per il giorno 26/10/2020 salvato come t2m_ana_2020-10-26.tif
rasterMZ=raster("C:\\WSL_folder\\t2m_ana_2020-10-26.tif")
# B2) Rasdaman
# start=format(start.date, "%Y-%m-%dT%H:%M:%OS3Z")
# end=format(end.date, "%Y-%m-%dT%H:%M:%OS3Z")
# intervallo=paste0('"',start,'":"',end,'"')
##> start: "2020-10-26T00:00:00.000Z"
##> end: "2020-10-26T23:00:00.000Z"
#somma
query='for $c in ( t2m_ana ) return encode(
condense +
over $t ansi(imageCrsDomain($c[ansi("2020-10-26T00:00:00.000Z":"2020-10-26T23:00:00.000Z")], ansi))
using $c[ansi($t)], "tiff")'
raster_tot=WPCS_query(proper_query=query, FORMAT="image/tiff", filename="C:\\WSL_folder\\tm2_ana_somma_RASDAMAN.tiff", query_url=NULL)
#media
query2='for $c in ( t2m_ana ) return encode(
condense +
over $t ansi(imageCrsDomain($c[ansi("2020-10-26T00:00:00.000Z":"2020-10-26T23:00:00.000Z")], ansi))
using ($c[ansi($t)]/24), "tiff")'
raster_gg=WPCS_query(proper_query=query2, FORMAT="image/tiff", filename=NULL, query_url=NULL)
raster_gg
plot(raster_gg)
# Verificare il valore medio in alcuni punti
pointCoordinates=read.csv("C:\\WSL_folder\\coordinate_stazioni.csv",header =TRUE, sep = ";")
pointCoordinates
CRS=raster_gg@crs
coordinates(pointCoordinates)=~UTM_EST+UTM_NORD
projection(pointCoordinates) <- CRS
#Step1: Plotto le stazioni
#compareCRS(raster_gg, pointCoordinates)
#> [1]TRUE
plot(pointCoordinates, add = TRUE)
# Step2:  Combine raster values with point and save as a CSV file.
values <- raster::extract(raster_gg, pointCoordinates)
valori_MZ <- raster::extract(rasterMZ, pointCoordinates)
x <- data.frame(pointCoordinates)
tmp <- cbind(x, tm2_ana_gg=values, tm2_ana_gg_MZ=valori_MZ)
tmp
write.table(tmp, file="C:\\WSL_folder\\combinedPointValue.csv", sep= ";")
writeRaster(raster_gg, filename="C:\\WSL_folder\\tm2_ana_gg_RASDAMAN.tiff", format = "GTiff", overwrite = TRUE)
print(paste0("Raster salvato in:",filename))
filename2="C:\\WSL_folder\\tm2_ana_gg_RASDAMAN.tiff"
writeRaster(raster_gg, filename=filename, format = "GTiff", overwrite = TRUE)
print(paste0("Raster salvato in:",filename2))
library(tmap)
tm_shape=tmap::tm_shape
tm_raster=tmap::tm_raster
tm_legend=tmap::tm_legend
tm_lines=tmap::tm_lines
tm_text=tmap::tm_text
tm_shape(rstr_finale) + tm_raster(style= "cont", palette = "-RdYlBu", title = paste("Tmedia del ",day,"\n (°C)"), interpolate = TRUE) +
tm_shape(rc) + tm_lines(col = "black", text = "level", breaks = rc$level, labels = as.character(rc$level)) +
tm_text("level", col = "white", size = 1.0) + tm_legend(outside = TRUE)
documents()
library("devtools")
setwd("C:\\WSL_folder\\myCubeR")
# Modifico i vari file .Rd, poi do il comando:
devtools::document() # o semplicemente: document()
build_site()
build_site()
build_site()
build_site()
devtools::document()
build_site()
build_site()
build_site()
build_site()
build_site()
build_site()
build_site()
